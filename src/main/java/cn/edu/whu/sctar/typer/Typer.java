package cn.edu.whu.sctar.typer;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import cn.edu.whu.cstar.simulator.CrashIndex;
import cn.edu.whu.cstar.simulator.RandomSimulator;
import cn.edu.whu.cstar.timer.CrashNode;
import cn.edu.whu.cstar.timer.RepsUtilier;
import weka.classifiers.functions.SGDText.Count;
import weka.core.Instances;
import weka.core.converters.ConverterUtils.DataSource;

/***
 * <p>Main entry of package <b>typer</b>. Running {@link#main} method can give 
 * the whole exception types (generated by 7 operator) of each project.</p>
 * @author yongfeng
 *
 */
@SuppressWarnings("unused")
public class Typer {

	public static void main(String[] args) {
		
		for(int i=1;i<=7;i++){
			try {
				typerInOpeators(i);
			} catch (Exception e) {
				System.out.println("[Error]: exception is thrown when typing project [" + i  +"].");
				e.printStackTrace();
			}
		}
		
		//// Finding the exception type distribution in each project (average on 10 datasets)
//		for(int i=1;i<=7;i++){
//			try {
//				typerIn500Crashes(i);
//			} catch (Exception e) {
//				System.out.println("[Error]: exception is thrown when typing project [" + i  +"].");
//				e.printStackTrace();
//			}
//		}
		
		//// Finding the crashes generated by each operators (original dataset)
//		for(int i=1;i<=7;i++){
//			try {
//				typerInProject(i);
//			} catch (Exception e) {
//				System.out.println("[Error]: exception is thrown when typing project [" + i  +"].");
//				e.printStackTrace();
//			}
//		}
		
		
		
		
		
	}
	
	public static void typerInOpeators(int projId) throws Exception{
		String path = "";
		String arff = "";
		
		switch(projId){
		case 1:
			path = "src/main/resources/crashrep/codec_mutants.txt";
			arff = "src/main/resources/crasharff/generated/codec";
			break;
		case 2:
			path = "src/main/resources/crashrep/collection_mutants.txt";
			arff = "src/main/resources/crasharff/generated/collections";
			break;
		case 3:
			path = "src/main/resources/crashrep/io_mutants.txt";
			arff = "src/main/resources/crasharff/generated/io";
			break;
		case 4:
			path = "src/main/resources/crashrep/jsoup_mutants.txt";
			arff = "src/main/resources/crasharff/generated/jsoup";
			break;
		case 5:
			path = "src/main/resources/crashrep/jsqlpraser_mutants.txt";
			arff = "src/main/resources/crasharff/generated/jsqlparser";
			break;
		case 6:
			path = "src/main/resources/crashrep/mango_mutants.txt";
			arff = "src/main/resources/crasharff/generated/mango";
			break;
		case 7:
			path = "src/main/resources/crashrep/ormlite_mutants.txt"; 
			arff = "src/main/resources/crasharff/generated/ormlite";
			break;
		default:
			System.out.println("[ERROR]: No such project id <" + projId + ">");
			break;
		}
		
		System.out.println("[project]: " + path);
		
		/** Read mutation line in MutationInfo.txt */
		File file = new File("src/main/resources/MutationInfo.txt");
		BufferedReader br = new BufferedReader(new FileReader(file));
		String str = "";
		List<String> lsContent = new ArrayList<String>(); // content of MutationInfo.txt
		while((str=br.readLine())!=null) { // for each line in MutationInfo.txt
			if(str.trim().equals("")){ continue; }
			lsContent.add(str);			
		}
		br.close();
		
		/** Crash Node list in stack trace */
		List<CrashNode> lsCrash = RepsUtilier.getSingleCrash(path);
		
		for(int i=1; i<=10; i++){ // 10 datasets for 1 project
			/** simulate the generation to get crash indexes */
			CrashIndex[] crashes = RandomSimulator.getDataset(path, 500, i);
			RandomSimulator.RandomizeByRand(crashes, 1);
			CrashIndex[] lsFinalCrashes = RandomSimulator.StratifyByFolds(crashes, 10);
			
			/** lsOperatorCol can be in the following way, each sub-list(operator) holds its exception type
			 * [0]: 12, 13, 11, 14 ,20, ...
			 * [1]: 21, 19, 14, 11, ...
			 * ...
			 * [6]: 11, 14, 16, 17, ...
			 */
			List<ArrayList<Integer>> lsOperatorCol = new ArrayList<ArrayList<Integer>>();
			for(int p=0; p<7; p++){
				lsOperatorCol.add(new ArrayList<Integer>());
			}
			
			for(int k=0; k<lsFinalCrashes.length; k++){
				CrashNode currentCrash = lsCrash.get(lsFinalCrashes[k].getCrashID());
				String mutLine = currentCrash.MutationLine;
				
				String stkClsName = getInformByStackTraceMutLine(mutLine)[0];
				String stkMedName = getInformByStackTraceMutLine(mutLine)[1];
				String stkLineNum = getInformByStackTraceMutLine(mutLine)[2];
				
				for(int j=0; j<lsContent.size(); j++){ // for each line in MutationInfo.txt
					
					String mutClsName = OperatorCollector.getInformsByFileMutLine(lsContent.get(j))[0];
					String mutMedName = OperatorCollector.getInformsByFileMutLine(lsContent.get(j))[1];
					String mutLineNum = OperatorCollector.getInformsByFileMutLine(lsContent.get(j))[2];
					
					if( stkClsName.equals(mutClsName) && stkMedName.equals(mutMedName) && stkLineNum.equals(mutLineNum)){
						int operator_id = OperatorCollector.getOperatorID(OperatorCollector.getInformsByFileMutLine(lsContent.get(j))[3]);
						int expType = currentCrash.getType();
						lsOperatorCol.get(operator_id).add(expType);
						break;
					}
				}
				
			}
			int[][] lsCount = new int[7][22];
			int[] aveCount = new int[22];
			for(int m = 0; m<lsOperatorCol.size(); m++){
				System.out.print("[" + m + "]: ");
				for(int exp: lsOperatorCol.get(m)){
					System.out.printf("%d ", exp);
				}
				System.out.println("");
				int[] count = FindingTop3(lsOperatorCol.get(m));
				for(int mm=0; mm<count.length; mm++){
					lsCount[m][mm] = count[mm];
					if(count[mm] > 0){
						System.out.print(mm + ":" + count[mm] + ", ");
					}	
				}
				System.out.println("");
			}
			for(int m=0; m<aveCount.length; m++){
				for(int l=0; l<lsCount[m].length; l++){
					aveCount[m] += lsCount[l][m];
				}
			}
			
			System.out.println(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
			for(int m=0; m<aveCount.length; m++){
				if(aveCount[m]>0){
					System.out.print(m + ":" + aveCount[m]);
				}
			}
			
			System.out.println("");
			
		}
		
		
	}
	
	/**
	 * <p>To count the average operation distribution in 500 crashes in each project.</p>
	 * @param projId
	 * @throws Exception
	 */
	public static void typerIn500Crashes(int projId) throws Exception{
		
		String path = "";
		String arff = "";
		
		switch(projId){
		case 1:
			path = "src/main/resources/crashrep/codec_mutants.txt";
			arff = "src/main/resources/crasharff/generated/codec";
			break;
		case 2:
			path = "src/main/resources/crashrep/collection_mutants.txt";
			arff = "src/main/resources/crasharff/generated/collections";
			break;
		case 3:
			path = "src/main/resources/crashrep/io_mutants.txt";
			arff = "src/main/resources/crasharff/generated/io";
			break;
		case 4:
			path = "src/main/resources/crashrep/jsoup_mutants.txt";
			arff = "src/main/resources/crasharff/generated/jsoup";
			break;
		case 5:
			path = "src/main/resources/crashrep/jsqlpraser_mutants.txt";
			arff = "src/main/resources/crasharff/generated/jsqlparser";
			break;
		case 6:
			path = "src/main/resources/crashrep/mango_mutants.txt";
			arff = "src/main/resources/crasharff/generated/mango";
			break;
		case 7:
			path = "src/main/resources/crashrep/ormlite_mutants.txt"; 
			arff = "src/main/resources/crasharff/generated/ormlite";
			break;
		default:
			System.out.println("[ERROR]: No such project id <" + projId + ">");
			break;
		}
		
		System.out.println("[project]: " + path);
						
		/////////////////////////////////////////
		// WAY 1
//		/** Crash Node list in stack trace */
//		List<CrashNode> lsCrash = RepsUtilier.getSingleCrash(path);
//		
//		for(int i=1; i<=10; i++){
//			/** simulate the generation to get crash indexes */
//			CrashIndex[] crashes = RandomSimulator.getDataset(path, 500, i);
//			RandomSimulator.RandomizeByRand(crashes, 1);
//			CrashIndex[] lsFinalCrashes = RandomSimulator.StratifyByFolds(crashes, 10);
//			
//			int[] arrTypes = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
//					0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
//			
//			for(int k=0; k<lsFinalCrashes.length; k++){
//				int expType = lsCrash.get(lsFinalCrashes[k].getCrashID()).getType();
//				arrTypes[expType]++;
////				System.out.printf(expType + ",");
//			}
//			
//			for(int m = 1; m<arrTypes.length; m++){
//				System.out.printf("[ %-2d : %-4d ] ", m, arrTypes[m]);
//			}
//			
//			System.out.println("");
//			
//		}
//		
//		System.out.println("-------------------------------------------------------------------");
		
		/////////////////////////////////////////
		// WAY 2
		int[] arrTypes = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
		
		int[][] sum = new int[11][22];
		
		for(int i=1; i<=10; i++){
			/** simulate the generation to get crash indexes */
			Instances ins = DataSource.read(arff + i + ".arff");
			ins.setClassIndex(ins.numAttributes()-1);
									
			for(int j=0; j<ins.numInstances(); j++){
				int expType = (int) ins.get(j).value(0);
//				arrTypes[expType]++;
				sum[i][expType]++;
			}			
			
//			for(int m = 1; m<arrTypes.length; m++){
//				System.out.printf("[ %-2d : %-4d ] ", m, sum[i][m]);
//			}
//			System.out.println("");
			
			for(int col =1; col<22; col++){
				for(int row = 1; row<11; row++){
					arrTypes[col] += sum[row][col];
					sum[row][col] = 0;
				}
			}
			
		}
		
		for(int m = 1; m<arrTypes.length; m++){
			if(arrTypes[m] > 0){
				System.out.printf("[%d] : %f ", m, arrTypes[m]*1.0/10);
			}
		}
			
		System.out.println("\n");
	}
	
	/**
	 * <p>To count the operation distribution in each project</p>
	 * @param projId
	 * @throws Exception
	 */
	public static void typerInProject(int projId) throws Exception{
		
		String path = "";
		
		switch(projId){
		case 1:
			path = "src/main/resources/crashrep/codec_mutants.txt";
			break;
		case 2:
			path = "src/main/resources/crashrep/collection_mutants.txt";
			break;
		case 3:
			path = "src/main/resources/crashrep/io_mutants.txt";
			break;
		case 4:
			path = "src/main/resources/crashrep/jsoup_mutants.txt";
			break;
		case 5:
			path = "src/main/resources/crashrep/jsqlpraser_mutants.txt";
			break;
		case 6:
			path = "src/main/resources/crashrep/mango_mutants.txt";
			break;
		case 7:
			path = "src/main/resources/crashrep/ormlite_mutants.txt"; 
			break;
		default:
			System.out.println("[ERROR]: No such project id <" + projId + ">");
			break;
		}
		
		System.out.println("[project]: " + path);
		
		/** Crash Node list in stack trace */
		List<CrashNode> lsCrash = RepsUtilier.getSingleCrash(path);
		
		/** Read mutation line in MutationInfo.txt */
		File file = new File("src/main/resources/MutationInfo.txt");
		BufferedReader br = new BufferedReader(new FileReader(file));
		String str = "";
		int[] expTypes = {0, 0, 0, 0, 0, 0, 0};
		List<String> lsContent = new ArrayList<String>();
		while((str=br.readLine())!=null) { // for each line in MutationInfo.txt
			if(str.trim().equals("")){ continue; }
			lsContent.add(str);			
		}
		
		br.close();
		
		for(int i=0; i<lsCrash.size(); i++){ // for each line in Crash Node list
			String mutLine = lsCrash.get(i).MutationLine;
//			System.out.printf("[mutation information] %s %s %s\n", 
//					getInformByStackTraceMutLine(mutLine)[0], 
//					getInformByStackTraceMutLine(mutLine)[1], 
//					getInformByStackTraceMutLine(mutLine)[2] );
			String stkClsName = getInformByStackTraceMutLine(mutLine)[0];
			String stkMedName = getInformByStackTraceMutLine(mutLine)[1];
			String stkLineNum = getInformByStackTraceMutLine(mutLine)[2];
			
			for(int j=0; j<lsContent.size(); j++){ // for each line in MutationInfo.txt
				
				String mutClsName = OperatorCollector.getInformsByFileMutLine(lsContent.get(j))[0];
				String mutMedName = OperatorCollector.getInformsByFileMutLine(lsContent.get(j))[1];
				String mutLineNum = OperatorCollector.getInformsByFileMutLine(lsContent.get(j))[2];
				
				if( stkClsName.equals(mutClsName) && stkMedName.equals(mutMedName)
						&& stkLineNum.equals(mutLineNum)){
					int operator_id = OperatorCollector.getOperatorID(OperatorCollector.getInformsByFileMutLine(lsContent.get(j))[3]);
					expTypes[operator_id]++;
//					System.out.println("[bingo]: " + stkClsName + stkMedName + stkLineNum);
					break;
				}
			}
		}
		
		/**print the mutation*/
		for(int i=0; i< expTypes.length; i++){
			if(expTypes[i] > 0){
				System.out.println("| " + i + " | " + expTypes[i] + " |");
			}
		}
		
	}
	
	/***
	 * <p>to get class, method, line number from the mutation line in stack trace file, e.g.,</p>
	 * <pre>--------------------------------------------------------------------
	 *MUTATIONID:&lt;&lt;net.sf.jsqlparser.util.TablesNamesFinder,visit ,507&gt;&gt;
	 *--------------------------------------------------------------------</pre>
	 * <table>
	 * <tr><td><b>[class]:</b>  </td> <td>net.sf.jsqlparser.util.TablesNamesFinder</td></tr>
	 * <tr><td><b>[method]:</b> </td> <td>visit</td></tr>
	 * <tr><td><b>[line]:</b>   </td> <td>507</td></tr>
	 * </table>
	 * @param mutline mutation line in st
	 * @return informs [0]: class, [1]: method, [2]: line number
	 */
	public static String[] getInformByStackTraceMutLine(String mutline){
		
		String[] informs = new String[3];
		
		String reg = "MUTATIONID:<<(.*),(.*),(\\d*)>>";
		Pattern pattern = Pattern.compile(reg);
		Matcher matcher = pattern.matcher(mutline);
		if(matcher.find()){
			String cls = matcher.group(1).trim();
			String med = matcher.group(2).trim();
			String lin = matcher.group(3).trim();
			
			informs[0] = cls;
			informs[1] = med;
			informs[2] = lin;
		}
		
		return informs;
		
	}
	
	/**
	 * <p>finding the exception type occurrences in give array list. </p>
	 * @param lsOperatorCol array list
	 * @return count int[22]
	 */
	public static int[] FindingTop3(ArrayList<Integer> lsOperatorCol){
		int[] count = new int[22];
		for(int j=0; j<lsOperatorCol.size(); j++){
			count[lsOperatorCol.get(j)]++;
		}
//		for(int i=1; i<22; i++){
//			System.out.print(i + ":" + count[i] + ", ");
//		}
//		System.out.println("");
		
		return count;
	}
	
	public static int[][] ArrayListAdding(int[][] lst1, int[][] lst2){
		
		if(lst1 == null || lst2 == null ){
			System.out.println("[Error]: lst1 or lst2 cannot be null!");
			return null;
		}
		
		if(lst1.length != lst2.length || lst1[0].length != lst2[0].length){
			System.out.println("[Error]: lst1 and lst2 should have same dimension!");
			return null;
		}
		
		int lenRow = lst1.length;
		int lenCol = lst1[0].length;
		
		int[][] sum = new int[lenRow][lenCol];
		
		for(int i=0; i<lenRow; i++){
			for(int j=0; j< lenCol; j++){
				sum[i][j] = lst1[i][j] + lst2[i][j];
			}
		}
		
		return sum;
	}

}
